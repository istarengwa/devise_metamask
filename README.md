# Devise MetaMask

`devise_metamask` is an extension for [Devise](https://github.com/heartcombo/devise) that allows users to authenticate in a Ruby on Rails application using their Ethereum accounts instead of passwords.  The gem relies on the [`eth`](https://github.com/se3000/ruby-eth) library to recover the public key and address from a message signed with MetaMask and to verify that it matches the address submitted by the client.  It follows the approach described in the blog post “Finally authenticating Rails users with MetaMask,” which recommends storing an Ethereum address and a per‑user random nonce, including that nonce and a timestamp in the message to sign, and rotating the nonce after each successful login to prevent replay attacks【138469095841911†L258-L300】.

## Requirements

- **Ruby >= 2.7** – The gemspec targets Ruby 2.7 or newer.  Check your version with `ruby -v`.
- **Rails >= 6** – The generator creates a migration using Active Record 7.x syntax.  It also works with Rails 6; adjust the migration version if needed.
- **Devise >= 4.7** – This gem integrates with Devise 4.7 and above.
- **MetaMask** – On the client side, users need the MetaMask browser extension (or another wallet) to sign messages via the `ethereum.request({ method: 'personal_sign', … })` API【138469095841911†L331-L377】.

## Installation

### 1. Add the gem to your project

If you have published the gem to RubyGems, simply add it to your `Gemfile`:

```ruby
gem 'devise_metamask'
```

and run `bundle install`.

If you are using a hosted or local version of the gem, specify the Git URL:

```ruby
gem 'devise_metamask', git: 'https://github.com/istarengwa/devise_metamask.git'
```

### 2. Run the generator

The gem provides a generator that automates the setup:

```bash
rails generate devise:metamask [Model]
```

By default the model is `User`.  The generator automates the entire setup:

- It creates `config/initializers/devise_metamask.rb` with default configuration for parameter names and model attributes.
- It generates a migration named `add_<model>_metamask_fields.rb` that adds `eth_address` and `metamask_nonce` columns to your model’s table and adds a unique index on `eth_address`.
- It injects `:metamask_authenticatable` into the `devise` call in your model if it isn’t already present.
- It copies a sample partial to `app/views/shared/_metamask_login.html.erb` with a button and JavaScript snippet to trigger the MetaMask login flow.
- It creates `app/controllers/metamask_controller.rb` with a `nonce` action that returns the stored nonce for a given Ethereum address in JSON.
- It adds a route `get '/metamask_nonce', to: 'metamask#nonce'` to your `config/routes.rb` so the client can fetch the nonce via `GET /metamask_nonce?address=…`.

When the generated controller receives a request for an address that does not yet exist in your database, it delegates the decision to your model via the class method `from_metamask`.  By default, this method creates a user with a placeholder e‑mail and a random password (see below), mais si votre modèle comporte d’autres validations, la création peut échouer.  Si `from_metamask` renvoie un enregistrement non persisté, le contrôleur répondra `404` afin que vous puissiez imposer un flux d’inscription personnalisé.  Vous pouvez surcharger `from_metamask(address, message)` dans votre modèle pour créer l’utilisateur avec les champs requis ou pour empêcher la création automatique.

Example for a `User` model:

```bash
rails generate devise:metamask User
rails db:migrate
```

### 3. Configure your model

The generator automatically adds `:metamask_authenticatable` to your Devise modules.  Your model should look like this:

```ruby
class User < ApplicationRecord
  devise :metamask_authenticatable, :registerable, :trackable
  # other Devise modules …
end
```

### 4. Adjust configuration (optional)

The `config/initializers/devise_metamask.rb` initializer defines sensible defaults.  You can override them to match your naming conventions:

```ruby
Devise.setup do |config|
  # Field names expected by your MetaMask form/JavaScript
  config.metamask_address_param   = 'address'
  config.metamask_message_param   = 'message'
  config.metamask_signature_param = 'signature'

  # Attributes on your model storing the Ethereum address and nonce
  config.metamask_eth_attribute   = :eth_address
  config.metamask_nonce_attribute = :metamask_nonce
end
```

### 5. Add the MetaMask connect button to your views

The generator copies a sample partial to `app/views/shared/_metamask_login.html.erb`.  This partial renders a “Connect with MetaMask” button and includes a small script that performs the sign‑in flow: it requests the user’s account, fetches the nonce from your server, constructs the message and sends the signed credentials to your sign‑in endpoint.

By default the controller generated by the gem will look up the user by Ethereum address and, if no record exists, create one and generate an initial nonce.  This ensures that the front‑end always receives a nonce without having to pre‑create users.

Render this partial wherever you want the button to appear, for example in `app/views/layouts/application.html.erb`:

```erb
<%= render 'shared/metamask_login' %>
```

You should adapt the JavaScript in the partial to match your application (API endpoints, handling of allowed networks, etc.).  The partial uses the configuration values defined in `config/initializers/devise_metamask.rb` to name the submitted parameters.  It also includes a placeholder for appending a network name if you enabled `config.metamask_allowed_networks`.

### 6. Restrict authentication to specific networks (optional)

If you want to ensure that users sign on a particular blockchain network (e.g. Ethereum mainnet or Base) you can configure a whitelist of allowed networks.  The strategy will only accept signatures whose message ends with one of these network identifiers.  For example, to restrict authentication to the Ethereum mainnet and the Base network:

```ruby
Devise.setup do |config|
  # … other configuration …
  # Only accept messages signed for these networks
  config.metamask_allowed_networks = %w[eth base]
end
```

On the client side, you must append the network name to the message you ask the user to sign, otherwise the signature will be rejected.  For instance, for Base (chain ID `0x2105`) and Ethereum (chain ID `0x1`) you could do:

```js
// Determine the current network and set a human‑readable name
const chainId = await ethereum.request({ method: 'eth_chainId' });
let networkName;
switch (chainId) {
  case '0x1':
    networkName = 'eth';
    break;
  case '0x2105':
    networkName = 'base';
    break;
  // add other networks as needed
  default:
    throw new Error('Unsupported network');
}

// Build the message including the network name
const message = `${title},${Date.now()},${nonce},${networkName}`;
const signature = await ethereum.request({
  method: 'personal_sign',
  params: [message, address]
});
```

This mechanism is optional; if `config.metamask_allowed_networks` is empty (the default), the gem accepts signatures from any network.  Remember that the signature algorithm itself is the same across all EVM networks【138469095841911†L286-L294】; the network check is purely an application‑level policy.
```

## Client‑side usage

To initiate authentication, your front‑end code should:

1. Request the user’s Ethereum address via `ethereum.request({ method: 'eth_requestAccounts' })`.
2. Fetch the nonce associated with that address from your server.  The blog post proposes storing a random nonce per user and rotating it after each login to prevent replay attacks【138469095841911†L258-L300】.
3. Build a message string containing a site title, the current timestamp and the nonce.  When calling `personal_sign`, MetaMask expects the message to be hex‑encoded UTF‑8【256823775269663†L300-L334】.  The generator’s partial performs this conversion automatically, but if you roll your own client code you can convert it like this:

   ```js
   const message = `${title},${Date.now()},${nonce}`;
   // Convert the message to a hex string (without 0x) using TextEncoder
   const utf8ToHex = (str) => {
     const bytes = new TextEncoder().encode(str);
     return Array.from(bytes)
       .map((b) => b.toString(16).padStart(2, '0'))
       .join('');
   };
   const hexMessage = `0x${utf8ToHex(message)}`;
   const signature = await ethereum.request({
     method: 'personal_sign',
     params: [hexMessage, address]
   });
   ```

   You should still send the original human‑readable message (not the hex version) to the server so that it can be checked and used to validate nonces and timestamps.

4. Submit the `metamask_address`, `metamask_message` and `metamask_signature` parameters to your Devise session endpoint (for example `POST /users/sign_in`).  The strategy provided by this gem will recover the signer's address using `Eth::Signature.personal_recover`, decode the message if necessary and authenticate the user if it matches the stored address【369635869403598†L156-L198】.

### Selecting a blockchain network

The signature algorithm used by MetaMask (EIP‑191/EIP‑155) is identical across all EVM‑compatible networks.  By default, the gem verifies that the signature matches the submitted address, regardless of which network the user is connected to.  If your application needs to restrict authentication to a specific chain (for example [Base](https://base.org/)), you can enforce this on the client:

- Query the current network’s chain ID using:

  ```js
  const chainId = await ethereum.request({ method: 'eth_chainId' });
  // Base mainnet chain ID is 0x2105 (decimal 8453)
  if (chainId !== '0x2105') {
    // optionally prompt the user to switch networks
    await ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: '0x2105' }]
    });
  }
  ```

- Include the network name or chain ID in the message you ask the user to sign.  For example:

  ```js
  const message = `${title},${Date.now()},${nonce},base`;
  const signature = await ethereum.request({
    method: 'personal_sign',
    params: [message, address]
  });
  ```

  You can then validate that the expected chain name or ID appears in the signed message either in your controller or by overriding the `valid_message?` method in `Devise::Strategies::MetamaskAuthenticatable`.

These additional checks ensure that users authenticate only on the desired network while keeping the server‑side verification unchanged.

## Available commands

This gem defines one generator:

- `rails generate devise:metamask [Model]` – Installs MetaMask authentication for the specified Devise model (defaults to `User`).  It creates an initializer, adds migration files and injects the module into your model.

Authentication itself is handled via the `:metamask_authenticatable` module and the associated Warden strategy.  As long as your sign‑in request includes the configured parameters, Devise will invoke the MetaMask strategy before falling back to other strategies.

## Working with MetaMask‑only accounts

This gem is flexible : you can combine MetaMask authentication with traditional e‑mail/password authentication or restrict certain accounts to wallet‑only.  Two helpers facilitate this:

### Detecting a MetaMask user

Models that include `:metamask_authenticatable` gain an instance method `metamask_user?`.  It returns `true` when the record has an Ethereum address and can be used in your views to hide or show fields conditionally.  For example, to hide the e‑mail and password fields in your profile form when the user signed in via MetaMask:

```erb
<% unless current_user.metamask_user? %>
  <%= f.label :email %>
  <%= f.email_field :email %>
  …
<% else %>
  <p>You signed in with your wallet <%= current_user.eth_address %> and do not need an e‑mail/password.</p>
<% end %>
```

### Updating e‑mail and password without the current password

By défaut, Devise exige la saisie du mot de passe actuel pour modifier l’e‑mail ou le mot de passe.  Pour les comptes créés via MetaMask, un mot de passe aléatoire est généré et l’utilisateur ne le connaît pas.  Vous avez deux options :

1. **Laissez l’utilisateur définir un e‑mail et un mot de passe après la première connexion** en contournant la vérification du mot de passe actuel.  Pour ce faire, surchagez `Devise::RegistrationsController` et, lorsque `current_user.metamask_user?` est vrai, utilisez `resource.update(account_update_params)` (ou `update_without_password`) à la place de `update_with_password`.  Par exemple :

   ```ruby
   # app/controllers/users/registrations_controller.rb
   class Users::RegistrationsController < Devise::RegistrationsController
     def update
       if current_user.metamask_user?
         if resource.update(account_update_params)
           redirect_to after_update_path_for(resource), notice: 'Account updated'
         else
           render :edit
         end
       else
         super
       end
     end
   end
   ```
   Mettez à jour vos routes pour utiliser ce contrôleur personnalisé :
   ```ruby
   devise_for :users, controllers: { registrations: 'users/registrations' }
   ```

2. **Ne pas proposer de modification d’e‑mail/mot de passe pour les comptes MetaMask**.  Vous pouvez simplement masquer les champs et laisser ces utilisateurs se connecter uniquement via leur portefeuille.  Dans ce cas, retirez les modules `:database_authenticatable` et `:validatable` de votre modèle ou rendez les validations conditionnelles afin qu’aucun e‑mail ni mot de passe ne soit exigé.

Quelle que soit l’option choisie, la méthode `metamask_user?` et l’implémentation par défaut de `from_metamask` vous offrent une base souple ; vous pouvez toujours adapter la création et la gestion des comptes en définissant votre propre méthode de classe `from_metamask` ou en personnalisant vos contrôleurs Devise.

## Contributing

Contributions are welcome!  If you find a bug or have an idea for an improvement, please open an issue or submit a pull request on [GitHub](https://github.com/istarengwa/devise_metamask.git).

## License

This gem is released under the MIT license.  See the `LICENSE.txt` file for details.
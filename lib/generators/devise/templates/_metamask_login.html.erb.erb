<div id="metamask-login">
  <button id="metamask-connect-button" type="button">Connect with MetaMask</button>
</div>

<script type="module">
  // This script attaches a click handler to the button and performs the MetaMask
  // sign-in flow.  It is intentionally simple; you may wish to extract
  // functions into your own JavaScript pack or stimulus controller.
  document.addEventListener('DOMContentLoaded', () => {
    const button = document.getElementById('metamask-connect-button');
    if (!button) return;
    button.addEventListener('click', async () => {
      if (typeof window.ethereum === 'undefined') {
        alert('MetaMask is not available.');
        return;
      }
      try {
        // Request accounts
        const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
        const address = accounts[0];
        // Fetch the nonce from your API (replace with your own endpoint)
        const response = await fetch(`/metamask_nonce?address=${address}`);
        const { nonce } = await response.json();
        // Build the message.  Append a network name if you use
        // config.metamask_allowed_networks.
        const messageParts = [];
        messageParts.push(document.title);
        messageParts.push(Date.now());
        messageParts.push(nonce);
        // TODO: append network name here if required
        const message = messageParts.join(',');
        // MetaMask expects the message data to be a hex‑encoded UTF‑8 string
        // when calling personal_sign【256823775269663†L300-L334】.  Convert the
        // human‑readable message into a hex string.  We still send the
        // original message to the server for verification.
        const utf8ToHex = (str) => {
          const bytes = new TextEncoder().encode(str);
          return Array.from(bytes).map((b) => b.toString(16).padStart(2, '0')).join('');
        };
        const hexMessage = `0x${utf8ToHex(message)}`;
        const signature = await ethereum.request({
          method: 'personal_sign',
          params: [hexMessage, address]
        });
        // Submit the credentials to your sign-in endpoint
        const body = new URLSearchParams();
        // Use configured parameter names or fall back to defaults
        body.append('<%= (Devise.respond_to?(:metamask_address_param) && Devise.metamask_address_param.present?) ? Devise.metamask_address_param : "metamask_address" %>', address);
        body.append('<%= (Devise.respond_to?(:metamask_message_param) && Devise.metamask_message_param.present?) ? Devise.metamask_message_param : "metamask_message" %>', message);
        body.append('<%= (Devise.respond_to?(:metamask_signature_param) && Devise.metamask_signature_param.present?) ? Devise.metamask_signature_param : "metamask_signature" %>', signature);
        // Include the Rails authenticity token to satisfy CSRF protection.
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
        const loginResponse = await fetch('<%= Rails.application.routes.url_helpers.new_session_path(model_name.downcase) rescue "/users/sign_in" %>', {
          method: 'POST',
          headers: Object.assign({ 'Content-Type': 'application/x-www-form-urlencoded' }, csrfToken ? { 'X-CSRF-Token': csrfToken } : {}),
          body: body.toString()
        });
        if (loginResponse.ok) {
          window.location.reload();
        } else {
          alert('Sign in failed');
        }
      } catch (err) {
        console.error(err);
        alert('Error signing in with MetaMask');
      }
    });
  });
</script>